% Introduction to Bioinformatics
% Lesson 5 - Python basics


# What we'll cover today

* Basic data types: What kinds of data does python know about
* Syntax: What constitutes a valid expression
* Variables: How we keep track of and pass around data
* Control flow: How we specify the behaviour of our program
* Functions: How we package functionality


# Context & motivation


# Why/when shell scripts?

* Plumbing together existing command line programs...


# Why/when R?

* Very tabular data (`data.frame`s are great)
* Very tabular data operations (plyr, dplyr, reshape2)
* Plotting (ggplot2, shiny)
* Ready to go statistics functions


# Why/when python?

* More flexible data structures
* Better performance
* More flexible / cleaner programming models => better for algorithmic development
* Better organization for building bigger programs
* Better stream (Unix stdin/stdout) support than R


# Other languages?

There are other languages that fit some of these characteristics, but python is nice because

* It's become popular amongst the scientific community
* It's relatively simpler in design than other languages
* It's relatively quick to write (not necessarily to run)


# Python Basics

_In which we investigate the building blocks of logic_


# Firing up a python "REPL"

REPL is short for Read Evaluate Print Loop.

```python
python
> print "Hello world"
```

Now you can enter in little bits of code as we go (type Ctrl-d or `exit` to get out)


# Basic data types

_The elements of logic_


# Why we want different data types

They allow us to be more expressive and careful about the things we're doing.

They let us more easily manage information, and relate it to the things in the world it represents.


# Scalar data types

* strings: `"this is a string"`
* ints: `42`
* floats: `3.14159`
* booleans: `True`


# Collection types

These are "containers" for other types of data (scalars, other collections, more complex data types...).


# Collection types

* tuples: `("Bob Jones", 42)`
    * fixed length
    * immutable (can't "change in place")
* lists: `["Bob Jones", "Jane Doe", "Ralph Nader"]`
    * variable length
    * mutable
* dictionaries: `{"name": "Bob Jones", "age": 42}`
    * variable length
    * mutable
    * arbitrary "key-value pairs"
    * no order guarantees


# More collection types...

We won't go into these as deeply, but it's worth being aware of them:

* generators:
    * "recipes" for a collection
    * generates each thing as you need it
    * good for "big data"
* sets
    * unique entries
    * no order guarantees


# Operations

_In which we manipulate and reason about objects_


# Numeric

* Addition: `3 + 4`
* Subtraction: `3 - 1`
* Multiplication: `4 * 5`
* Division: `6 / 5`
* Exponentiation: `10 ** 2`
* Modulo (remainder): `42 % 5`

You can create more complex expressions using parentheses for grouping: `(4 + 5) * 2`


# String

`+` works for strings too:

`"this" + "that"`


# Boolean

* Logical and: `True & False` or `True and True`
* Logical or: `False | True` or `False or False` (not exclusive...)


# Blurring the lines with booleans

* You can also treat `True` and `False` like ints `1` and `0`, respectively, and vice versa
* Scalars other than `0`, `""`, `False` or `None` will be treated as `True` in logical expression ("truthy")
* Empty collections will be treated as "falsey" in logical expressions, all other collections truthy


# Variables

Like in the shell, we can give things names

<!--Next time around should focus on seqrecord examples instead of person examples from here on out.-->
<!--```python-->
<!--seqname = "BG234"-->
<!--seq = "AGCTAGCT"-->
<!--seqrecord = {"seqname": seqname, "seq": seq}-->
<!--```-->

```python
age = 42
name = "Bob Jones"
person = {"name": name, "age": age}

# We can use variables just as though they were their values
age / 4
```


# Variable name rules

* Must start with a character
* Can contain characters, numbers, and underscores (`_`); nothing else
* Standard convention is to use all lower case, with words separated by `_`

Example: `bobs_occupation = "haxxor"`


# Collection operations

We'll mostly focus on lists and dictionaries


# Lists

Writing `xs = [1, 2, 3, 4, 5, 6, 7]` defines a list `xs`.

* Concatenation: `+`
* Accessing: `xs[4]`
    * Get the 5th thing in the list
* Changing: `xs[3] = 999`
    * Change the 4th thing in the list

Note: Python has 0-based indexing.


# Dictionaries

These work similarly to lists, but the indices are (almost) whatever we want:

* Get the value: `person["name"]`
* Set the value: `person["occupation"] = "haxxor"`

Here `"occupation"` is the _key_, and `"haxxor"` is the _value_.
Together, they form a _key-value pair_.


# Dictionaries - arbitrary keys

Keys are often strings, but don't have to be:

```python
crazy_dict = {4: "some string", (1,2,3): 999}

crazy_dict[4]
crazy_dict[(1,2,3)]
```

They can be numbers, tuples or anything _hashable_.
However, they cannot be lists or other dictionaries.


# Functions

_In which from our rules of logic we compose spells_


# Writing a simple function

```python
def square(n):
    ans = n * n
    return ans

square(4)
```

* When we call the function with the argument `4`, that value gets passed in for the variable `n` in the _body_ of the function.
* To get a value out of the function we must use `return`
* Python uses 4 spaces of indentation to separate what's in the body of the function from what's not
    * In other languages, indentation is just "good practice" for readability; Python enforces it as part of the _syntax_


# Other things about functions

Functions are "first class", in that they can be passed around as data just like numbers, strings, etc.

```python
# Using our square function as a value
print square
[square, "data"]
```

We'll see how this is useful later.


# Methods

In python, methods are just functions that are bound to particular objects as _attributes_ of that object.

Example: `"this".upper()`

Example2: `xs = [1, 2, 3]; xs.append(9); print xs`

You can see what methods are bound to an object `o` with `dir(o)` (example: `dir([])` shows all list methods)

(We'll learn more about how methods actually work next week)


# Control flow

_In which we gain mastery over the rules of logic_


# If statements

```python
if 3 < 4:
    print "You should see this"
else:
    print "You should NOT see this!"
```

Things to note:

* We used indentation here as well to determine the structure of the statements
* We used the `<` (less than) operand, which behaves just as you'd expect, return True/False depending on the operand values


# You can have elif sections too

`elif` is a combination of an `else` and an `if`.

```python
def f(n):
    if n < 5:
        print "Cond 1"
    elif n > 10:
        print "Cond 2"
    else:
        print "Cond 3"

f(3)
f(7)
f(12)
```


# For statements

Do something for every thing in a collection:

```python
for n in xs:
    print "On int:", n

```


# Iterating over key-value pairs in a dictionary

Dictionaries have an `items` method that gives all of the <br/> key, value pairs. Try
```python
person.items()
```

Now loop over them:
```python
for k, v in person.items():
    print "key:", k, "val:", v

```


# Using `for` to build results

```python
ys = []
for x in xs:
    y = square(x)
    ys.append(y)

print ys
```

This is _imperative_; we're telling the computer _how_ to build `ys`


# A better way

List comprehensions:

```python
ys = [square(x) for x in xs]

print ys
```


# The functional way

```python
ys = map(square, xs)

print ys
```

Note that we're passing the function `square` as an _argument_ to the function `map`.


# Declarative is better

List comprehension and functional approaches are more _declarative_.

We tell the computer _what_ to compute, not _how_ we want it computed.
This is usually a good thing (cleaner code; sometimes better performance).


# Higher level concerns

_In which we begin to rise to the level of systems_


# Importing modules

```python
import math

dir(math)
help(math.log)

math.log(3.14)
```

`math` is a _module_.
Modules, just like objects, have _attributes_, and these attributes are typically functions that we can use in our programs (though sometimes they're just useful data, like `math.e`).


# Namespaces

We also talk about modules as being _namespaces_.
A namespace is just a path to some data or function or module.
In this case `math` can also be thought of as a namespace.

Namespaces help us avoid naming conflicts.
If we have a function called `square`, and we import a module like `math` with a function called `square`, namespaces let
us distingush between them.


# Installing your own packages with pip

Collections of modules are called _packages_.

You can install Python packages using the `pip` command line tool (the "App Store" for Python packages):

```python
pip install --user biopython
```

The `--user` flag tells pip to install things in your _local_ python lib directory.
You would only omit that if you were installing _system wide_ on your own computer.


# Beware Python 3

We're using Python 2.
Python 3 has been out for YEARS, but adoption has been slow.
Eventually, Python 3 will become the system default and more widely used, but till then...

Bottom line: Python 3 is rather different in a number of ways, so be aware.


# Resources

* Code Academy [Python course](http://www.codecademy.com/tracks/python) (I highly recommend working through as much of this as you like)
* Very clear blog post on [how python variables work](http://nedbatchelder.com/text/names.html)

[Back to homepage](http://fredhutchio.github.io/intro-bioinformatics/)

