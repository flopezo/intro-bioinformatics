% Introduction to Bioinformatics
% Lesson 4 - Version control with `git`


# Git for Version control!

_In which with our fleets of flying, speaking beasts we gain mastery over time_


# The basic idea

Like Back to the Future on steroids (without the DeLorean):

* Save your current state, with a helpful message
* Go back to an old state to try a different strategy, saving steps along the way
* Take two alternate histories and merge results


# In computational biology

Version control lets us keep track of our project

Analogy from the book:

> Imagine you keep a lab notebook in pencil, and each time you run a PCR you erase your past specifics and jot down the newest ones...

This is functionally equivalent to not versioning your code...


# Git

We'll be using `git` to version our project from here on out.

There are other version control systems out there (`svn`, `mercurial`, etc.), but `git` is currently by far the most popular in bioinformatics, and it's lovely!


# Getting yourself set up with git

```
git config --global user.name "Bob Jones"
git config --global user.email "bob@bobjones.edu"

# Some nice color modes for git output
git config --global color.ui true
```


# Getting git set up in our repository

```
# Get to project dir
cd ~/bioinfclass

# Initialize our "repository"
git init
git status
```


# Making our first commit

```
# Tell git what files to track
git add *

# Make initial commit
git commit -m "Initial commit"
```

We now have a saved state on which to build without fear of "messing things up".


# Let's make some edits, and save the changes

Write some things in `README.md`:

```
# Bioinfclass Notes

Where you type out notes and stuff...


## Jun 24, 2015

Learned how to use git!
It was pretty fun.

```


# Seeing what's changed

```
# Check the status of the repo
git status

# Seeing specific changes
git diff
```

Git diff uses + and - to show what's changed, and can be made to color dadditions / deletions.


# Saving our changes

```
# Stage the changed file
git add README.md

# Commit the changes, and add a commit message
git commit -m "Adding notes to README.md"

# Checking our status
git status
git log
```


# GitHub!

The *de facto* home of open source on the internet.

Visit [github.com](https://github.com) and log in.


# Forking

## A way of copying a project over to your account

* Go to <https://github.com/fredhutchio/bioinfclass-sample-project>
* Click on the button that says "Fork"
* Copy the "SSH clone URL" of the project


# Cloning a repository

## This is how we get a remote repository from GitHub checked out on our computers

```
# Go home, and rename the directory we've been working on
cd ~
mv bioinfclass old_bioinfclass

# Make the checkout
git clone git@github.com:metasoarous/bioinfclass-sample-project.git bioinfclass

# Enter the directory we created
cd bioinfclass

# See what's there
tree
git status
```


# Looking at history

```
# See the list of commits
git config log
```


# A slightly better way...

```
# Add an alias to a prettier log command
git config --global alias.glog "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%C(bold blue)<%an>%Creset' --abbrev-commit --all"

# Try it out!
git glog

git glog -n 5
```


# Tracing history

We can see the diffs for each commit with `git show`:


```
git show 1aa457d
git show f566a9
git show cac1218
# Skipping a couple..
git show d07378b
```


# `git show` only some files

```
# Very long...
git show 2c17799

# If we really just care about build.sh changes...
git show build.sh
```

This is pretty valuable as your project gets big and lots of things change.


# Let's make some changes

In README.md, add:

```
## June 24, 3:30PM

Ran the location trees.
Interesting data.
Thinking about some other studies now.
```


# Adding a new commit, as before

```
git add README.md

git commit -m "README notes about location analyses"
```


# Pushing our changes to GitHub

```
# Pushing changes on branch `master` to remote `origin`
git push origin master
```

Now pull up github, reload and see the new commit there.


# Sharing your changes with a "pull request"

Like "forking", this is a GitHub specific thing.

* Click on the little "double arrows" next to the branch drop down
* Note the "base" and "head" forks: base is where the changes will go, head is where they're from
* Click "Create pull request"


# If you get a pull request, you can merge it

This will show up on the repository page.

Some pull requests can be merged automatically, others need to be done from the command line.


# How to go "back in time"

Pick a commit to check out, like `b445eea`

* Type `git checkout -b backintime b445eea`: creates a new "branch" named `backintime` based on the desired commit
* Reload the script file


# Make some edits

Instead of worrying about making trees for each location, let's just directly count the number of sequence names per location to make sure they match up.

```
  # ...

  # Directly count number of sequences
  loc_spec_count="$loc_outdir/seqcount"
  wc -l $loc_sequences > $loc_spec_count
done

# Combine sequence counts by location
loc_spec_counts="$outdir/location_specimen_counts.txt"
find $outdir -name seqcount | xargs cat > $loc_spec_counts
```

# Now commit and look at our tree

```
git add build.sh
git commit -m "Added direct sequence per location count"

# Now look at our history; we've branched!
git glog
```


# Some guidelines

* Commit often
* Try to make commits "atomic" and messages short but good


# Challenges for bigger data

Having biggish data that updates frequently can slow git down quite a bit.

One solution is to track the output data (and maybe even input data) in separate repositories, which you "ignore" from the main repository.
This has a few problems too though:

* It's more work keeping multiple repositories up to date
* It's more work matching the code / data versions when split across repositories

GitHub is [solving this for large files](https://github.com/blog/1986-announcing-git-large-file-storage-lfs), but the problem remains for _lots_ of smaller files...


# Exercises

* Create a new branch and add something to it, then merge back in to master
* Merge the `backintime` branch we created with your master branch
* Create a new repository and push it to your account on GitHub


# Resources

* [Git Cheat sheet](http://www.git-tower.com/blog/git-cheat-sheet/)
* Tutorial: <https://try.github.io/>
* [Codeschool tutorial](https://www.codeschool.com/courses/try-git)
* [Markdown cheat sheet](http://assemble.io/docs/Cheatsheet-Markdown.html) (note that there are different "flavors" of markdown, with subtle differences...)
